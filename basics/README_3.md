## Управляющие конструкции

Условный оператор в if, как и в других языках программирования, представлен конструкцией if и условное выражение. 
А в качестве условия в Go может быть только булевая переменная, поскольку в Go нет приведения типов автоматически, 
то вы не можете, как, например, в C PHP, написать пустую строку или ноль, чтобы ваше выражение прошло. Нет. Вы должны 
четко свести это к условному выражению.

```go
// простое условие
boolVal := true
if boolVal {
    fmt.Println("boolVal is true")
}
```

Кроме того, кроме простых условий, есть условие с блоком инициализации, где вы можете получить результат какой-то 
функции, либо, например, получить значение существования ключа в map'е. После того как вы провели блок инициализации, 
вы можете поставить точку с запятой и уже там написать ваши выражения, которые будут проверяться для выполнения этого 
условия. В данном случае мы проверяем, что ключ существует или не существует. Также, если вам в данном случае не нужно 
само значение, которое вы получаете, а только проверка на существование ключа, то вы можете пропустить само значение, 
используя пустую переменную, то есть символ подчеркивания так, чтобы компилятор Go не ругался на неиспользуемую 
переменную.

```go
mapVal := map[string]string{"name": "rvasily"}
// условие с блоком инициализации
if keyValue, keyExist := mapVal["name"]; keyExist {
    fmt.Println("name =", keyValue)
}
// получаем только признак сущестования ключа
if _, keyExist := mapVal["name"]; keyExist {
    fmt.Println("key 'name' exist")
}
```

В Go также есть множественный if else, когда вы можете комбинировать их в одну длинную цепочку.

```go
cond := 1
// множественные if else
if cond == 1 {
    fmt.Println("cond is 1")
} else if cond == 2 {
    fmt.Println("cond is 2")
}
```

Оператор *switch* может работать по одной переменной, и в блоке case вы будете указывать условия, которым должна 
удовлетворять эта переменная. Но есть нюансы. Во-первых, нюанс, что в отличие, например, от C, где по умолчанию в 
switch case у вас происходит проваливание в следующее условие и вам нужно писать везде break, в Go такого нет, и 
проваливание по умолчанию отсутствует. Вам, наоборот, нужно писать fallthrough, для того чтобы ваша программа 
провалилась в следующее условие. Также в условиях, то есть в блоке case, может стоять не одно значение, а несколько, 
перечисленные через запятые. Ну и конечно же, есть блок default, который будет выполнен тогда, когда ни одно из этих 
условий не применилось.

```go
// switch по 1 переменной
strVal := "name"
switch strVal {
    case "name":
        fallthrough
    case "test", "lastName":
        // some work
    default:
        // some work
}

// switch как замена многим ifelse
var val1, val2 = 2, 2
switch {
    case val1 > 1 || val2 < 11:
        fmt.Println("first block")
    case val2 > 10:
        fmt.Println("second block")
}
```

Также иногда бывает нужно вам выйти из case, завершить его где-то на середине. Для этого вы можете использовать 
оператор break. Тогда вы не пройдете в следующее условие, а выйдете из switch. Иногда бывает нужно, чтобы в операторе 
switch вы завершили какой-то цикл. В этом случае вам нужно указать метку этому циклу, и поставить эту метку после 
break.


```go
	// выход из цикла, находясь внутри switch
Loop:
    for key, val := range mapVal {
        println("switch in loop", key, val)
        switch {
            case key == "lastName":
            break
            println("dont pront this")
        case key == "firstName" && val == "Vasily":
            println("switch - break loop here")
        break Loop
    }
} // конец for
```

### [Пример 1](control.go)

В Go цикл представлен только одной конструкцией for, но она может принимать совершенно разные формы. 
Во-первых, есть конструкция, когда у вас нет условия и это бесконечный цикл. Это аналог while(true) либо for (;;;). 
В этом случае вам этот цикл нужно прервать самостоятельно. Для этого используется конструкция break. Следующим видом 
цикла является цикл с одиночным условием. То есть цикл будет выполняться до тех пор, пока это условие истинно. 
Это аналог while переменная.

```go
// цикл без условия, while(true) OR for(;;;)
for {
    fmt.Println("loop iteration")
    break
}

// цикл без условия, while(isRun)
isRun := true
for isRun {
    fmt.Println("loop iteration with condition")
    isRun = false
}
```

Третьим вариантом цикла, является классический for из C, когда вы указываете блок инициализации, блок с условием и 
блок, который выполняется после итерации цикла. Чаще всего там автоинкремент индекса, по которому идет цикл.

Переход к следующей итерации цикла, ключевое слово *continue*.

```go
// цикл с условие и блоком инициализации
for i := 0; i < 2; i++ {
    fmt.Println("loop iteration", i)
    if i == 1 {
        continue
    }
}
```

Еще одним примером будет операция по слайсам. Мы будем печатать значение, печатать индекс и сами делать автоинкремент. 
Такое не очень удобно, поэтому гораздо чаще используется цикл с инициализацией, с условием и операцией после цикла.
Оператор range заменяет всю рутину, как указать первоначальный индекс, указать условие, указать инкремент для этого 
индекса, вам достаточно просто проитерироваться, используя оператор *range*. Оператор range может вам вернуть либо 
индекс, только индекс из этого слайса, и вы уже сами можете вывести у него значение.

```go
// операции по slice
sl := []int{1, 2, 3}
idx := 0

for idx < len(sl) {
    fmt.Println("while-stype loop, idx:", idx, "value:", sl[idx])
    idx++
}

for i := 0; i < len(sl); i++ {
    fmt.Println("c-style loop", i, sl[i])
}
for idx := range sl {
    fmt.Println("range slice by index", sl[idx])
}
for idx, val := range sl {
    fmt.Println("range slice by idx-value", idx, val)
}
```

Также вы можете итерироваться в цикле по map. Вы можете итерироваться как только по ключам этой map и сами обращаться 
к ее значениям. В этом случае стоит заметить, что в map порядок включений не определен. Это значит, что в разных 
запусках программы ключи в памяти во внутреннюю структуру map могут располагаться совершенно по-разному. Это 
обусловлено особенностями реализации. То есть не ожидайте, что ключи будут в map ровно в том порядке, в котором вы 
их добавляли. Также вы можете сразу проитерироваться по ключу и по значению из map, также используя оператор range. 
Либо если вам ключ не нужен, вы можете использовать, как всегда, пустую переменную — символ подчеркивания — и 
итерироваться только по значениям map.

```go
// операции по map
profile := map[int]string{1: "Vasily", 2: "Romanov"}

for key := range profile {
    fmt.Println("range map by key", key)
}

for key, val := range profile {
    fmt.Println("range map by key-val", key, val)
}

for _, val := range profile {
    fmt.Println("range map by val", val)
}
```

Отдельно стоит отметить итерирование по строке. Строка внутри себя представляет слайс байт, но range для строки 
определен отдельно. Это значит, что, итерируясь по строке по типу string, вы будете итерироваться не по байтам, а уже 
по отдельным символам. И в том, что вам возвращает range для строки, будет позиция, то есть номер, на котором 
находится ваш символ, и непосредственно символ, то есть руна, которую представляет собой utf-ный символ.

```go
str := "Привет, Мир!"
for pos, char := range str {
    fmt.Printf("%#U at pos %d\n", char, pos)
}
```

### [Пример 2](loop.go)