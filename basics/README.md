### Переменные, базовые типы данных

Переменная в go объявляется при помощи ключевого слова var, после которой следует имя переменной и тип переменной. 
При этом вы можете не указывать значения по умолчанию, при этом вы можете не указывать значения при инициализации, и 
тогда переменная будет инициализирована значением по умолчанию.

```go
// значение по умолчанию
var num0 int
```

Итак, вы можете просто объявить переменную через var, вы можете сразу присвоить ей значение. Для некоторых типов 
данных вы можете пропустить указание типа, и компилятор определит этот тип автоматически.

```go
// значение при инициализации
var num1 int = 1
```

Иногда бывает так, что вам нужно что-то вернуть из функции и очень не хочется писать имя и тип переменной, которая
там будет. Для этих целей в go есть короткое объявление. Оно осуществляется при помощи оператора *:=*. Однако используя
короткое объявление, вы можете объявить только новую переменную, то есть присвоить значение в уже существующую 
переменную, используя этот оператор, вы не сможете.

```go
// короткое объявление переменной
num := 30
// только для новых переменных
// no new variables on left side of :=
// num := 31
```

Есть постфиксный инкремент, но нет префиксного инкремента. 

```go
// ++num нет
num++
```

В go можно объявить сразу несколько переменных через запятую и сразу же проинициализировать их. Можно присвоить
им значение после объявления. Также вы можете использовать короткое присваивание для объявления нескольких переменных,
однако хотя бы одна из этих переменных должна быть новой.


```go
// объявление нескольких переменных
var weight, height int = 10, 20

// присваивание в существующие переменные
weight, height = 11, 21

// короткое присваивание
// хотя-бы одна переменная должна быть новой!
weight, age := 12, 22
```

## [Пример 1](vars_1.go)

Давайте рассмотрим, какие еще есть типы данных. Мы начинали с *int*. int вообще платформозависимый тип в go. Он имеет 
разрядность либо *32 бита*, либо *64 бита* в зависимости от вашей операционки. int, конечно, выбирается автоматически.

```go
// int - платформозависимый тип, 32/64
var i int = 10

// автоматически выбранный int
var autoInt = -10
```

Если вас не устраивает разрядность или вы хотите большего контроля, то в go поддержка от *int8* до *int64*, которая 
позволяет хранить очень большие значения. 

```go
// int8, int16, int32, int64
var bigInt int64 = 1<<32 - 1
```

Есть *беззнаковый int — uint*, он тоже может быть платформозависимым. Если опять-таки платформозависимость вас не 
устраивает, к вашим услугам от uint8 до uint64.

```go
// платформозависимый тип, 32/64
var unsignedInt uint = 100500

// uint8, unit16, uint32, unit64
var unsignedBigInt uint64 = 1<<64 - 1
```

*Числа с плавающей точкой* представлены как одинарной точности float 32, так и двойной точности. Для них тоже есть 
автоподстановка типа, значение по умолчанию — это тоже ноль.

```go
// float32, float64
var pi float32 = 3.141
var e = 2.718
goldenRatio := 1.618
```

*Булевая переменная*. В булевых переменных значение по умолчанию ноль, и оно тоже может угадываться автоматически.

```go
// bool
var b bool // false по-умолчанию
var isOk bool = true
var success = true
cond := true
```

В go есть *комплексные переменные*.

```go
// complex64, complex128
var c complex128 = -1.1 + 7.12i
c2 := -1.1 + 7.12i
```

## [Пример 2](vars_2.go)

*Строки*. Строки — это очень важный тип данных. По умолчанию для строки — это пустая строка. 
Строка объявляется в двойных кавычках, и при этом внутри этих двойных кавычек могут быть спецсимволы, 
такие как перенос строки либо символ табуляции. Если же вы хотите писать как есть, то вы можете использовать backtick'и,
обратные кавычки, и символ новой строки либо табуляции там будет прямо, как мы описали, слэш n.
В go строки из коробки поддерживают UTF-8, поэтому вы можете там писать на практически любых алфавитах, на русском, 
в данном случае на китайском.

```go
// пустая строка по-умолчанию
var str string

// со спец символами
var hello string = "Привет\n\t"

// без спец символов
var world string = `Мир\n\t`

// UTF-8 из коробки
var helloWorld = "Привет, Мир!"
hi := "你好，世界"
```

Одинарные кавычки в go используются для символов byte, который является по сути alias'ом для uint8. Либо же для rune, 
который представляет собой полноценный UTF-8 символ. Внутри это uint32.

```go
// одинарные кавычки для байт (uint8)
var rawBinary byte = '\x27'

// rune (uint32) для UTF-8 символов
var someChinese rune = '茶'
```

Строки в go вы можете компилировать, то есть соединять между собой при помощи оператора плюс.

```go
helloWorld = "Привет Мир"
// конкатенация строк
andGoodMorning := helloWorld + " и доброе утро!"
```

Однако строки в go незаменяемы, вы не можете заменить там какой-то один символ.

```go
// строки неизменяемы
// cannot assign to helloWorld[0]
// helloWorld[0] = 72
```

Если вы попробуете получить длину строки, используя встроенную функцию len, то вы получите длину в байтах. 
Иногда это может запутать, потому что это не символы. Если там лежит внутри utf, то один символ может занимать больше
одного байта. Если же вы хотите получить именно количество символов, вам придется воспользоваться специальной функцией
RunCountInString из пакета utf8.

```go
// получение длины строки
byteLen := len(helloWorld)                    // 19 байт
symbols := utf8.RuneCountInString(helloWorld) // 10 рун
```

Также вы можете получить часть строки, подстроку, используя оператор срез. Вы можете получить, начиная с какого байта 
и по какой байт.

```go
// получение подстроки, в байтах, не символах!
hello = helloWorld[:12] // Привет, 0-11 байты
H := helloWorld[0]      // byte, 72, не "П"
```

Еще одной особенностью строк является то, что их можно конвертировать в слайс байт.

```go
// конвертация в слайс байт и обратно
byteString := []byte(helloWorld)
helloWorld = string(byteString)
```

## [Пример 3](strings.go)

*Константа* в go определяется при помощи ключевого слова const, после которой идет имя переменной, имя этой константы и 
опционально ее тип. При этом вы можете объявить сразу блок констант, то есть не указывая ключевое слово перед каждой 
константой.

```go
const pi = 3.141
const (
    hello = "Привет"
    e     = 2.718
)
```

*iota* — это такой автоинкремент для константы.

```go
const (
    zero = iota
    _    // пустая переменная, пропуск iota
    two
    three // = 3
)
const (
    _         = iota             // пропускаем первое значение
    KB uint64 = 1 << (10 * iota) // 1 << (10 * 1) = 1024
    MB                           // 1 << (10 * 2) = 1048576
)
```

*Нетипизированная константа*, которой вы не объявили тип сами, она так и остается внутри нетипизированной. И может в 
нужное место подставиться уже с нужным типом. За счет этого, например, константы в go иметь целочисленные значения, 
значительно превышающие 64 бита. Но вот в данном случае у меня есть переменная «месяц», которая имеет тип int32. 
Я могу добавить к ней год, year, потому что это нетипизированная константа. При этом если я попробую добавить 
типизированную константу, то компилятор заругается, что так нельзя, надо преобразовывать тип.

```go
const (
    // нетипизированная константа
    year = 2017
    // типизированная константа
    yearTyped int = 2017
)
```

## [Пример 4](strings.go)

В go вы можете определять собственные типы, либо основываясь на каких-то базовых примитивах, либо используя более 
сложные конструкции, такие как структуры, о которых мы будем говорить отдельно. Тип очень полезно А определять, если 
вы хотите моделировать уже какие-то сущности. В данном случае у меня тип UserID.

```go
type UserID int
```

Особенностью Go является то, что здесь нет никакого автоматического приведения типов никуда. И для того чтобы привести
какую-то переменную базового типа к другому типу, который тоже основан на базовом типе, мне придётся сделать 
конвертацию, в данном случае это типы совместимые, я могу, используя объявление типа и скобки, привести его к нужному 
мне UserID. То есть idx у меня типа int, а myID будет тип UserID. Также вы можете конвертировать простые int'ы между
собой, или, как я уже показывал, строку со слайсом байт

## [Пример 5](type.go)

Начать надо с того, что в Go нет адресной арифметики. Вы не можете прибавить какое-то значение к указателю и получить
указатель на другую область памяти. В Go указатель — это отдельный тип данных. Что это значит? Это значит, что если
вы объявляете какую-то переменную как указатель на другую, то внутри этой переменной будет лежать значение адреса на 
другую переменную.
То есть это не является полноценной ссылкой, которая указывает ровно туда же, куда и основная переменная.

Итак, в данном случае я объявляю переменную a, и в переменную b я кладу указатель на a. Теперь я могу положить внутрь 
значение, которое лежит за b, используя оператор *, я могу положить 3, и внутри a значение изменится. Через c я создам 
новый указатель на a. Если же вам нужно создать указатель на какой-то тип данных, что часто используют, например,
в структурах, то вы можете использовать ключевое слово int, точнее встроенную функцию int, которая создаст вам 
переменную нужного типа, заполнит её значением по умолчанию, что важно, у вас там не будет мусора, и вернёт вам 
указатель на эту переменную. Теперь в данном случае... Итак, я сделал, получив указатель на int. Теперь я могу 
изменить какое-то значение. Также я могу в c, в значение, которое лежит за c, положить значение, которое лежит внутри
d. И, таким образом, переменная a, указателем на которую является c, она изменится. При этом теперь я меняю d, и c и
a уже не меняются, потому что c указывает на a, а не становится сразу же ссылкой на d. Однако теперь дальше я говорю,
что c теперь — указатель на d, точнее в c теперь находится тот же указатель, который находится внутри d. И если я 
изменю c, изменю значение, которое лежит за c, то изменится значение, которое лежит внутри d, но не значение, 
которое лежит внутри a. Работа с указателями — довольно важная часть в Go, но вы ознакомитесь с ней уже во время 
практики.

## [Пример 5](pointers.go)

