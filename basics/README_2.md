## Переменные, составные типы данных

*Массив* — это какой-то набор из нескольких данных, одного типа. Особенностью массивов в Go является то, что размер 
массива — это часть типа данных. Что это значит? Это значит, что массив размерностью 2 и массив размерностью 3 — это 
два совершенно разных типа данных и они между собой несовместимы. Причем размерность массива задается при компиляции, 
она не может быть изменена динамически.

```go
// размер массива является частью его типа

// инициализация значениями по-умолчанию
var a1 [3]int // [0,0,0]

const size = 2
var a2 [2 * size]bool // [false,false,false,false]

// определение размера при объявлении
a3 := [...]int{1, 2, 3}
```

Если же я попробую обратиться к массиву, выходя за его пределы, то это будет проверено при инициализации. Если это 
константа, и код просто не скомпилируется. Если же там будет такой id индекс, то это будет проверено уже в run time, 
и программа завершится паникой.

### [Пример 1](array.go)

*Слайс* — это чуть-чуть более сложная структура данных, чем массив, потому что у слайса есть его длина, то есть то 
количество элементов, которое там уже есть. И *capacity*, то есть то количество элементов, которое влезет еще в этот 
слайс без аллоцирования дополнительной памяти.

Встроенная функция *make*, которая создает массив нужной размерности и capacity.

```go
// создание
var buf0 []int             // len=0, cap=0
buf1 := []int{}            // len=0, cap=0
buf2 := []int{42}          // len=1, cap=1
buf3 := make([]int, 0)     // len=0, cap=0
buf4 := make([]int, 5)     // len=5, cap=5
buf5 := make([]int, 5, 10) // len=5, cap=10

// обращение к элементам
someInt := buf2[0]

// ошибка при выполнении
// panic: runtime error: index out of range
// someOtherInt := buf2[1]
```

Для того чтобы добавить элемент в слайс, есть специальная функция append, первым параметром которой передается сам 
слайс, а далее идут значения, которые вы хотите добавить.

```go
// добавление элементов
var buf []int            // len=0, cap=0
buf = append(buf, 9, 10) // len=2, cap=2
buf = append(buf, 12)    // len=3, cap=4
```

Если у вас есть слайс, вы хотите его домержить в текущий слайс, то для этого есть специальный оператор троеточие.

```go
// добавление друго слайса
otherBuf := make([]int, 3)     // [0,0,0]
buf = append(buf, otherBuf...) // len=6, cap=8
```

Используя встроенную функцию len, которая говорит вам длину массива, то есть сколько там уже элементов, и функцию cap, 
capacity, которая говорит, сколько памяти аллоцировано.


```go
// просмотр информации о слайсе
var bufLen, bufCap int = len(buf), cap(buf)
```

### [Пример 2](slice_1.go)

Еще одной особенностью слайса является то, что вы можете взять какой-то кусок его, который будет ссылаться ровно на 
ту же область памяти, на которую ссылается оригинальный слайс.

```go
buf := []int{1, 2, 3, 4, 5}

// получение среза, указывающего на ту же память
sl1 := buf[1:4] // [2, 3, 4]
sl2 := buf[:2]  // [1, 2]
sl3 := buf[2:]  // [3, 4, 5]

newBuf := buf[:] // [1, 2, 3, 4, 5]
// buf = [9, 2, 3, 4, 5], т.к. та же память
newBuf[0] = 9

// newBuf теперь указывает на другие данные
newBuf = append(newBuf, 6)

// buf    = [9, 2, 3, 4, 5], не изменился
// newBuf = [1, 2, 3, 4, 5, 6], изменился
newBuf[0] = 1
```

Для того чтобы скопировать полноценно, нам нужно создать новый слайс, такой же размерности и такой же длины, и уже 
скопировать в него. Тогда это будет правильный вариант, вы получите ожидаемое поведение. Еще копии может 
копировать — это не обязательно должна быть переменная, это может быть срез, слайс, который 
вы только что получили, который ссылается на какую-то другую область памяти, то есть на другой слайс, на часть 
другого слайса.

```go
// копирование одного слайса в другой
var emptyBuf []int // len=0, cap=0
// неправильно - скопирует меньшее (по len) из 2-х слайсов
copied := copy(emptyBuf, buf) // copied = 0
fmt.Println(copied, emptyBuf)

// правильно
newBuf = make([]int, len(buf), len(buf))
copy(newBuf, buf)
fmt.Println(newBuf)

// можно копировать в часть существующего слайса
ints := []int{1, 2, 3, 4}
copy(ints[1:3], []int{5, 6}) // ints = [1, 5, 6, 4]
```

### [Пример 3](slice_2.go)

*map*, он же хеш-таблица, он же ассоциативный массив, он же сложное слово «отображение». map позволяет по ключу быстро 
получить значение. Это очень удобно, когда у вас значений довольно много. И если бы они лежали в слайсе, вам бы 
пришлось все перебирать, а так вы сразу идете в нужное место.

есть одна особенность: если там этого элемента нету по этому ключу, то вам вернется значение по умолчанию. Про это 
надо знать, потому что если вдруг у вас мапа, которая состоит из булов, то значение по умолчанию для була — это 
false. И вам вернется false.

```go
// инициализация при создании
var user map[string]string = map[string]string{
"name":     "Vasily",
"lastName": "Romanov",
}

// сразу с нужной ёмкостью
profile := make(map[string]string, 10)

// количество элементов
mapLength := len(user)
```

Для разрешения этой ситуации можно получить признак существования ключа. Он может быть получен, используя вторую 
переменную при обращении к мапе. В данном случае я получаю признак существования ключа в переменную nNameExist. То 
есть и в нем уже будет лежать булевая переменная, которая будет говорить, был там ключ либо не было там ключа.

```go
// если ключа нет - вернёт значение по умолчанию для типа
mName := user["middleName"]

// проверка на существование ключа
mName, mNameExist := user["middleName"]

// пустая переменная - только проверяем что ключ есть
_, mNameExist2 := user["middleName"]
```

Удаление ключа происходит через встроенную функцию delete. delete, указываете мапу и указываете ключ — все просто.

```go
// удаление ключа
delete(user, "lastName")
```

### [Пример 4](map.go)